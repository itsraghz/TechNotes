# Java Record

Record is a new *data type* introduced as a *preview feature* (not certain, but on testing mode) in Java 14, and later it was confirmed in Java 17 as a basic language feature.

A `record` is a new *keyword* added in the Java ecosystem to mark it a reserved word, not to be used for any other identifier.

Record is similar to a class but with a few great advantages and a few noticeable disadvantages.

## What exactly is a Record in a technical sense?

A Record is a datatype and also a class defined in the package `java.lang`. Whenver you declare an user defined type and specify it as a `record`, it extends the `java.lang.Record` internally, hence preventing a record to be extending any other class.

## A Sample 

```java
[access-modifier] record <nameOfTheType> (<datatype member1>[, <datatype member2>, ...]) {}
```

```java
public record Person(String name, int age) {}
```

We have just created/declared a `Person` as a `record` with two attributes - `name` of type `String`, and `age` of type `int`. That is all. It is now a fullfledged user defined type, ready to use in a normal sense as that of a `class`, even with the constructors autogenerated, similar to a class.

## Record Vs Class

Mostly, Record is treated as a simplified version of a class that wraps up the _much-needed-but-can-be-potentially-avoided_ *boilerplate* code in the declaration of the User defined Structure (so far we know it has been defined as a `class`).

What does it actually wrap it up? In a typical Java class, we have the attributes (members), and behaviors (methods). For each of the attribtutes, we may need the accessors and mutators, or in other words - getters and setters. In addition, we may also need the `toString()`, `hashCode()` and `equals()` - on demand to have a meaningful implementation as desired. 

All these put together may certainly elongate the definition of the `class`, easily about 50 lines of code for 2 members/attributes, making it *verbose*. A `record` technically helps the Programmer avoid manually typing all these verbose codes (boilerplate), and rather just focus on the declaration of the attributes, where the rest of all can be automatically taken care. 

### How does `record` really help bringing out the hidden features?

Techically, for a Java Compiler, we *should* need all the boiler plate code to work, as we don't have any optimization at that level. However, we just bring these optimization to the Programmer/Developer so that (s)he does not need to get overwhelmed on these trivial and mundante tasks, which otherwise needs time to type OR even get them as an auto-generated code, thanks to the IDE's intelligence. Nevertheless, they *visibly* become a part of your source code making it too lengthy or verbose.

The `record` on the other hand generates all the boilerplate code behind the scenes so as to satify the compiler during the compilatin phase for the much needed syntactic evaluvations and parsing. You can compile a `record` and *disassemble* the code using `javap` utility shipped along with the JDK to see all these automagically appearing in the compiled version of the code in the `.class` file. 

## Pros

## Cons

## Summary

## References
